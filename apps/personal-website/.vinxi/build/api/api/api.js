import{AsyncLocalStorage as v}from"node:async_hooks";import{H3Event as h,getRequestWebStream as R,getRequestURL as P,eventHandler as x}from"h3";function S(e={}){let t,o=!1;const r=n=>{if(t&&t!==n)throw new Error("Context conflict")};let s;if(e.asyncContext){const n=e.AsyncLocalStorage||globalThis.AsyncLocalStorage;n?s=new n:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const a=()=>{if(s){const n=s.getStore();if(n!==void 0)return n}return t};return{use:()=>{const n=a();if(n===void 0)throw new Error("Context is not available");return n},tryUse:()=>a(),set:(n,i)=>{i||r(n),t=n,o=!0},unset:()=>{t=void 0,o=!1},call:(n,i)=>{r(n),t=n;try{return s?s.run(n,i):i()}finally{o||(t=void 0)}},async callAsync(n,i){t=n;const l=()=>{t=n},u=()=>t===n?l:void 0;g.add(u);try{const f=s?s.run(n,i):i();return o||(t=void 0),await f}finally{g.delete(u)}}}}function T(e={}){const t={};return{get(o,r={}){return t[o]||(t[o]=S({...e,...r})),t[o]}}}const d=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},p="__unctx__",A=d[p]||(d[p]=T()),E=(e,t={})=>A.get(e,t),y="__unctx_async_handlers__",g=d[y]||(d[y]=new Set);function H(e){let t;const o=b(e),r={duplex:"half",method:e.method,headers:e.headers};return e.node.req.body instanceof ArrayBuffer?new Request(o,{...r,body:e.node.req.body}):new Request(o,{...r,get body(){return t||(t=I(e),t)}})}function C(e){return e.web??(e.web={request:H(e),url:b(e)}),e.web.request}function L(){return U()}const w=Symbol("$HTTPEvent");function q(e){return typeof e=="object"&&(e instanceof h||e?.[w]instanceof h||e?.__is_event__===!0)}function _(e){return function(...t){var o;const r=t[0];if(q(r))t[0]=r instanceof h||r.__is_event__?r:r[w];else{if(!((o=globalThis.app.config.server.experimental)!=null&&o.asyncContext))throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");t.unshift(L())}return e(...t)}}const b=_(P),I=_(R);function $(){var e;return E("nitro-app",{asyncContext:!!((e=globalThis.app.config.server.experimental)!=null&&e.asyncContext),AsyncLocalStorage:v})}function U(){const e=$().use().event;if(!e)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");return e}const W=[{path:"/__root",filePath:"/Users/fernando/Documents/Manual Library/github/projects/code-docs/apps/personal-website/src/routes/__root.tsx"},{path:"/",filePath:"/Users/fernando/Documents/Manual Library/github/projects/code-docs/apps/personal-website/src/routes/index.tsx"}],B=["GET","POST","PUT","PATCH","DELETE","OPTIONS","HEAD"];function N(e){return x(async t=>{const o=C(t);return await e({request:o})})}function M(e,t){const o=e.pathname.split("/").filter(Boolean),r=t.sort((s,a)=>{const n=s.routePath.split("/").filter(Boolean);return a.routePath.split("/").filter(Boolean).length-n.length}).filter(s=>{const a=s.routePath.split("/").filter(Boolean);return o.length>=a.length});for(const s of r){const a=s.routePath.split("/").filter(Boolean),n={};let i=!0;for(let l=0;l<a.length;l++){const u=a[l],f=o[l];if(u.startsWith("$"))if(u==="$"){const c=o.slice(l).join("/");if(c!=="")n["*"]=c,n._splat=c;else{i=!1;break}}else{const c=u.slice(1);n[c]=f}else if(u!==f){i=!1;break}}if(i)return{routePath:s.routePath,params:n,payload:s.payload}}}const m=W.filter(e=>e.$APIRoute);function D(e){const t=[];return e.forEach(o=>{const s=o.path.split("/").filter(Boolean).map(a=>a==="*splat"?"$":a.startsWith(":$")&&a.endsWith("?")?a.slice(1,-1):a).join("/");t.push({routePath:`/${s}`,payload:o})}),t}const O=async({request:e})=>{if(!m.length)return new Response("No routes found",{status:404});if(!B.includes(e.method))return new Response("Method not allowed",{status:405});const t=D(m),o=new URL(e.url,"http://localhost:3000"),r=M(o,t);if(!r)return new Response("Not found",{status:404});let s;try{s=await r.payload.$APIRoute.import().then(i=>i.APIRoute)}catch(i){return console.error("Error importing route file:",i),new Response("Internal server error",{status:500})}if(!s)return new Response("Internal server error",{status:500});const a=e.method,n=s.methods[a];return n?await n({request:e,params:r.params}):new Response("Method not allowed",{status:405})},G=N(O);export{G as default};
